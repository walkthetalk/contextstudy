\startbuffer[sectitlecontext]
\cnglo{context}
\stopbuffer
\section{\getbuffer[sectitlecontext]}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%clGetDeviceIDs
可以用如下函数创建一个\scopencl\cnglo{context}。所创建的\scopencl\cnglo{context}是与一个或多个\cnglo{device}相关的。\scopencl\scruntime使用\cnglo{context}来管理对象，如\cnglo{cmdq}、\cnglo{memobj}、\cnglo{programobj}和\cnglo{kernelobj}；以及在\cnglo{context}中所指定的一个或多个\cnglo{device}上执行\cnglo{kernel}。
\startclc
cl_context clCreateContext(
		const cl_context_properties *properties,
		cl_uint num_devices,
		const cl_device_id *devices,
		void (CL_CALLBACK *pfn_notify)(
			const char *errinfo,
			const void *private_info,
			size_t cb,
			void *user_data),
		void *user_data,
		cl_int *errcode_ret)
\stopclc

\carg{properties}指定了\cnglo{context}的一系列属性，包括属性的名字和相应的值。每个属性名称后面紧跟其对应的期望值。此清单以0结尾。\reftab{prptForclCreateContext}列出了所支持的属性。如果\carg{properties}是\cenum{NULL}，选择哪些\cnglo{platform}\cnglo{impdef}。

\cltable
{\placetable[here,force][tab:prptForclCreateContext]{clCreateContext所支持的属性清单}}
{\input{tbl/tbl_prpt_clCreateContext.tex}}

\carg{num_devices}是参数\carg{devices}中\cnglo{device}的数目。

\startbuffer[buffnunique]
\carg{devices}中重复的\cnglo{device}会被忽略。
\stopbuffer
\carg{devices}指向一个\cnglo{device}清单，其中的设备都是由\capi{clGetDeviceIDs}所返回的，而且是独一无二{\footnote{\getbuffer[buffnunique]}}的。

\carg{pfn_notify}是\cnglo{app}所注册的一个回调函数。\scopencl的实现可以用这个回调函数来报告此\cnglo{context}中所发生的错误。\scopencl的实现可能会异步调用此回调函数。\cnglo{app}负责保证此回调函数的线程安全。这个回调函数的参数是:
\startigBase
\item \carg{errinfo}指向一个错误字符串。
\item \carg{private_info}和\carg{cb}会提供一个指向二进制数据的指针，这些数据是由 \scopencl实现所返回，可以用来记录一些附加信息来帮助调试错误。
\item \carg{user_data}指向用户提供的数据。
\stopigBase
如果\carg{pfn_notify}是\cenum{NULL}，代表没有注册回调函数。

注意：大量情况下，如果在\cnglo{context}外发生了错误，有必要发出错误通告。发布通告时可能不会调用\carg{pfn_notify}。这些通告会发布给谁\cnglo{impdef}。

\carg{user_data}会在调用\carg{pfn_notify}时作为参数\carg{user_data}使用。\carg{user_data}可以是\cenum{NULL}。

\carg{errcode_ret}用来返回相应错误码，如果\carg{errcode_ret}是\cenum{NULL}，则不返回错误码。

如果成功创建了\cnglo{context}，\capi{clCreateContext}会返回此（非零）\cnglo{context}，并将\carg{errcode_ret}置为\cenum{CL_SUCCESS}。否则返回\cenum{NULL}，并将\carg{errcode_ret}置为下列错误码之一：
\startigBase
\item \cenum{CL_INVALID_PLATFORM}——如果\carg{properties}是\cenum{NULL}并且无可选\cnglo{platform}，或者\carg{properties}中\cnglo{platform}的值无效。
\item \cenum{CL_INVALID_PROPERTY}——如果\carg{properties}中的\cnglo{context}属性名不受支持，或者支持此属性但其值无效，或者同一属性名出现多于一次。
\item \cenum{CL_INVALID_VALUE}——如果\carg{devices}是\cenum{NULL}。
\item \cenum{CL_INVALID_VALUE}——如果\carg{num_devices}等于0。
\item \cenum{CL_INVALID_VALUE}——如果\carg{pfn_notify}是\cenum{NULL}但\carg{user_data}不是\cenum{NULL}。
\item \cenum{CL_INVALID_DEVICE}——如果\carg{devices}中有无效的\cnglo{device}。
\item \cenum{CL_DEVICE_NOT_AVAILABLE}——如果\carg{devices}中的某个\cnglo{device}当前不可用，即使此\cnglo{device}是由\capi{clGetDeviceIDs}返回的。
\item \cenum{CL_OUT_OF_RESOURCES}——如果\scdevfailres。
\item \cenum{CL_OUT_OF_HOST_MEMORY}——如果\schostfailres。
\stopigBase

函数\capi{clCreateContextFromType}\footnote{\capi{clCreateContextfromType}可能返回平台中现有的与\carg{device_type}相匹配的所有实际物理设备，也可能只返回其中一个子集。}会根据\cnglo{device}类型创建一个\scopencl\cnglo{context}，此\cnglo{device}类型用来标识要使用的\cnglo{device}。
\startclc
cl_context clCreateContextFromType(
		const cl_context_properties *properties,
		cl_device_type device_type,
		void (CL_CALLBACK *pfn_notify)(
			const char *errinfo,
			const void *private_info,
			size_t cb,
			void *user_data),
		void *user_data,
		cl_int *errcode_ret)
\stopclc

\carg{properties}指定了\cnglo{context}的一系列属性，包括属性的名字和相应的值。每个属性名称后面紧跟其对应的期望值。此清单以0结尾。\reftab{prptForclCreateContext}列出了所支持的属性。如果\carg{properties}是\cenum{NULL}，选择哪些\cnglo{platform}\cnglo{impdef}。

\carg{device_type}是位域，用来标识\cnglo{device}类型，参见\reftab{cldevctgr}。

\carg{pfn_notify}和\carg{user_data}跟\capi{clCreateContext}中所描述的一样。

\carg{errcode_ret}用来返回相应错误码，如果\carg{errcode_ret}是\cenum{NULL}，则不返回错误码。

如果成功创建了\cnglo{context}，\capi{clCreateContextFromType}会返回此（非零）\cnglo{context}，并将\carg{errcode_ret}置为\cenum{CL_SUCCESS}。否则返回\cenum{NULL}，并将\carg{errcode_ret}置为下列错误码之一：
\startigBase
\item \cenum{CL_INVALID_PLATFORM}——如果\carg{properties}是\cenum{NULL}并且无可选\cnglo{platform}，或者\carg{properties}中\cnglo{platform}的值无效。
\item \cenum{CL_INVALID_PROPERTY}——如果\carg{properties}中的\cnglo{context}属性名不受支持，或者支持此属性但其值无效，或者同一属性名出现多于一次。
\item \cenum{CL_INVALID_VALUE}——如果\carg{pfn_notify}是\cenum{NULL}但\carg{user_data}不是\cenum{NULL}。
\item \cenum{CL_INVALID_DEVICE_TYPE}——如果\carg{device_type}的值无效。
\item \cenum{CL_DEVICE_NOT_AVAILABLE}——如果当前没有与\carg{device_type}和\carg{properties}中的属性值相匹配的\cnglo{device}可用。
\item \cenum{CL_DEVICE_NOT_FOUND}——如果没有找到与\carg{device_type}和\carg{properties}中的属性值相匹配的\cnglo{device}。
\item \cenum{CL_OUT_OF_RESOURCES}——如果\scdevfailres。
\item \cenum{CL_OUT_OF_HOST_MEMORY}——如果\schostfailres。
\stopigBase

函数\capi{clRetainContext}会使\carg{context}的\cnglo{refcnt}加一。
\startclc
cl_int clRetainContext(cl_context context)
\stopclc

如果执行成功，\capi{clRetainContext}会返回\cenum{CL_SUCCESS}。否则返回下列错误码之一：
\startigBase
\item \cenum{CL_INVALID_CONTEXT}——如果\carg{context}不是一个有效的\scopencl\cnglo{context}。
\item \cenum{CL_OUT_OF_RESOURCES}——如果\scdevfailres。
\item \cenum{CL_OUT_OF_HOST_MEMORY}——如果\schostfailres。
\stopigBase

\capi{clCreateContext}和\capi{clCreateContextFromType}会执行隐式的\cnglo{retain}。这对第三方库非常有用，使其可以直接获取由\cnglo{app}传给它们的\cnglo{context}。然而，\cnglo{app}可能会在没有通知库的情况下删除此\cnglo{context}。允许函数附到\cnglo{context}上(如\cnglo{retain})或释放\cnglo{context}，这样，在库所使用的\cnglo{context}不再有效时就不会出问题。

函数\capi{clReleaseContext}会使\carg{context}的\cnglo{refcnt}减一。
\startclc
cl_int clReleaseContext(cl_context context)
\stopclc

如果执行成功，\capi{clReleaseContext}会返回\cenum{CL_SUCCESS}。否则返回下列错误码之一：
\startigBase
\item \cenum{CL_INVALID_CONTEXT}——如果\carg{context}不是一个有效的\scopencl\cnglo{context}。
\item \cenum{CL_OUT_OF_RESOURCES}——如果\scdevfailres。
\item \cenum{CL_OUT_OF_HOST_MEMORY}——如果\schostfailres。
\stopigBase

当\carg{context}的\cnglo{refcnt}变成0，且所有附到其上的对象（如\cnglo{memobj}、\cnglo{cmdq}）都
被释放了的时候，\carg{context}就会被删除。

函数\capi{clGetContextInfo}可以用来查询一个\cnglo{context}的相关信息。
\startclc
cl_int clGetContextInfo(cl_context context,
	cl_context_info param_name,
	size_t param_value_size,
	void *param_value,
	size_t *param_value_size_ret)
\stopclc

\carg{context}指定所要查询的\scopencl\cnglo{context}。
\carg{param_name}是枚举常量，指定要查询什么信息。
\carg{param_value}是一个指针，指向所返回的查询结果。如果\carg{param_value}是\cenum{NULL}，则被忽略。
\carg{param_value_size}的值就是\carg{param_value}所指内存的字节数。必须大于等于\reftab{paramNameclGetContextInfo}中所描述的返回类型的大小。
\carg{param_value_size_ret}会返回\carg{param_value}所查数据的实际字节数。如果\carg{param_value_size_ret}是\cenum{NULL}，则被忽略。

\reftab{paramNameclGetContextInfo}列出了\carg{param_name}的值和\capi{clGetContextInfo}返回的\carg{param_value}中的信息。

\cltable
{\placetable[here,force][tab:paramNameclGetContextInfo]{\capi{clGetContextInfo}所支持的\carg{param_names}的清单}}
{\input{tbl/tbl_param_clGetContextInfo.tex}}

如果执行成功，\capi{clGetContextInfo}会返回\cenum{CL_SUCCESS}。否则，返回下列错误码之一：
\startigBase
\item \cenum{CL_INVALID_CONTEXT}——如果\carg{context}不是一个有效的\scopencl\cnglo{context}。
\item \cenum{CL_INVALID_VALUE}——如果\carg{param_name}的值不受支持，或者\carg{param_value_size}
的值小于\reftab{paramNameclGetContextInfo}中返回类型的大小且\carg{param_value}不是\cenum{NULL}。
\item \cenum{CL_OUT_OF_RESOURCES}——如果\scdevfailres。
\item \cenum{CL_OUT_OF_HOST_MEMORY}——如果\schostfailres。
\stopigBase

