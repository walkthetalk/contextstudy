\startbuffer[sectitlequerydevice]
查询\cnglo{device}
\stopbuffer
\section{\getbuffer[sectitlequerydevice]}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%clGetDeviceIDs
可以用如下函数获得一个\cnglo{platform}上可用\cnglo{device}的清单\footnote{\capi{clGetDeviceIDs}可能返回\carg{platform}中所有与\carg{device_type}匹配的真正的物理设备，也可能只是其中一个子集。}。
\startclc
cl_int clGetDeviceIDs(
		cl_platform_id platform,
		cl_device_type device_type,
		cl_uint num_entries,
		cl_device_id *devices,
		cl_uint *num_devices)
\stopclc

\carg{platform}用来指明要查询哪个平台的\cnglo{device}，它可能是\capi{clGetPlatformIDs}所返回的，也可能是\cenum{NULL}。如果是\cenum{NULL}，则行为\cnglo{impdef}。

\carg{device_type}是位域，用来指明要查询哪些类型的\scopencl\cnglo{device}，可以仅查询某一种，也可以查询所有的。其有效值如\reftab{cldevctgr}。

\startbuffer[tblcapdevctgrlist]
\scopencl\cnglo{device}种类清单
\stopbuffer
\cltable
{\placetable[here,force][tab:cldevctgr]{\getbuffer[tblcapdevctgrlist]}}
{\input{tbl/tbl_dev_ctgr.tex}}

\carg{num_entries}是可以加入\carg{devices}中的\ctype{cl_device}表项的数目。如果\carg{devices}不是\cenum{NULL}，则\carg{num_entries}必须大于0。

\carg{devices}用来返回所找到的\scopencl\cnglo{device}的清单。\carg{devices}中的\ctype{cl_device_id}的值可以用来标识一个特定的\scopencl\cnglo{device}。如果参数\carg{devices}是NULL，则忽略此参数。所返回的\scopencl\cnglo{device}的数目是如下两个数目中较小的一个：\carg{num_entries}，类型为\ctype{device_type}的\scopencl\cnglo{device}的数目。

\carg{num_devices}返回与\ctype{device_type}相匹配的可用\scopencl\cnglo{device}的数目。如果\carg{num_devices}是NULL，则忽略此参数。

如果执行成功，则\capi{clGetDeviceIDs}会返回\cenum{CL_SUCCESS}。否则，返回下列错误码之一：
\startigBase
\item \cenum{CL_INVALID_PLATFORM}，如果\carg{platform}无效。
\item \cenum{CL_INVALID_DEVICE_TYPE}，如果\carg{device_type}无效。
\item \cenum{CL_INVALID_VALUE}，如果\carg{num_entries}等于零且\carg{devices}不是\cenum{NULL}，或者\carg{num_devices}和\carg{devices}都是\cenum{NULL}。
\item \cenum{CL_DEVICE_NOT_FOUND}，如果没有找到任何与\carg{device_type}匹配的\scopencl\cnglo{device}。
\item \cenum{CL_OUT_OF_RESOURCES}，如果\scdevfailres。
\item \cenum{CL_OUT_OF_HOST_MEMORY}，如果\schostfailres。
\stopigBase

对于\capi{clGetDeviceIDs}返回的\scopencl\cnglo{device}，\cnglo{app}可以查询其\sccapability。\cnglo{app}可以据其来决定使用哪些\cnglo{device}。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%clGetDeviceInfo
可以用函数\capi{clGetDeviceInfo}获取一个\scopencl\cnglo{device}的特定信息，这些信息如表 4.3所示。
\startclc
cl_int clGetDeviceInfo(
		cl_device_id device,
		cl_device_info param_name,
		size_t param_value_size,
		void *param_value,
		size_t *param_value_size_ret)
\stopclc

\carg{device}是\capi{clGetDeviceIDs}所返回的一个\cnglo{device}。

\carg{param_name}是一个枚举常量，用来指名要查询那种信息，其值可以在表4.3所列数值中选取。

\carg{param_value}是一个指针，所指内存中存储有\carg{param_name}所对应的值。如果\carg{param_value}是\cenum{NULL}，则忽略。

\carg{param_value_size}的值就是\carg{param_value}所指内存的字节数，其值必须>=表 4.3所列的返回类型的大小。
 
\carg{param_value_size_ret}返回\carg{param_value}所对应数据的实际大小。如果\carg{param_value_size_ret}是\cenum{NULL}，则忽略。

\startbuffer[tblcapdevquery]
\scopencl\cnglo{device}查询
\stopbuffer

\startbuffer[footnoteprofile]
平台\scprofile返回\scopencl\cnglo{framework}所实现的\scprofile。如果返回的是\cenum{FULL_PROFILE}，则\scopencl\cnglo{framework}支持\cenum{FULL_PROFILE}的\cnglo{device}，可能也支持\cenum{EMBEDDED_PROFILE}的\cnglo{device}。编译器必须对所有\cnglo{device}可用，即\cenum{CL_DEVICE_COMPILER_AVAILABLE}必须是\cenum{CL_TRUE}。如果\cnglo{platform}\scprofile是\cenum{EMBEDDED_PROFILE}，则只支持\cenum{EMBEDDED_PROFILE}的\cnglo{device}。
\stopbuffer

\cltable
{\placetable[here,force][tab:cldevquery]{\getbuffer[tblcapdevquery]}}
{\input{tbl/tbl_dev_query.tex}}

如果执行成功，\capi{clGetDeviceInfo}会返回\cenum{CL_SUCCESS}；否则，返回下列错误之一：

\startigBase
\item \cenum{CL_INVALID_DEVICE}——如果\carg{device}无效。
\item \cenum{CL_INVALID_VALUE}——如果\cenum{param_name}的值不受支持，或者\cenum{param_value_size}的值<\reftab{cldevquery}中返回类型的大小并且\cenum{param_value}不是\cenum{NULL}。
\item \cenum{CL_OUT_OF_RESOURCES}——如果\scdevfailres。
\item \cenum{CL_OUT_OF_HOST_MEMORY}——如果\schostfailres。
\stopigBase




