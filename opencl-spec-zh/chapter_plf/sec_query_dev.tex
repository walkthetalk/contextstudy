\startbuffer[sectitlequerydevice]
查詢\cnglo{device}
\stopbuffer
\section{\getbuffer[sectitlequerydevice]}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%clGetDeviceIDs
函式 \capi{clGetDeviceIDs}
\footnote{\capi{clGetDeviceIDs} 可能返回\carg{platform}中所有與 \carg{device_type} 匹配的真正的物理設備，也可能只是其中一個子集。}
可以用來獲取一個\cnglo{platform}上所有可用\cnglo{device}的清單。
\startclc
cl_int clGetDeviceIDs(
		cl_platform_id platform,
		cl_device_type device_type,
		cl_uint num_entries,
		cl_device_id *devices,
		cl_uint *num_devices)
\stopclc

\carg{platform} 即 \capi{clGetPlatformIDs} 所返回的\cnglo{platform} ID，或者是 \cenum{NULL}。
如果是 \cenum{NULL}，則其行為\cnglo{impdef}。

\carg{device_type} 是位域（ bitfield )，用來標識 OpenCL \cnglo{device}的類型。
可以用來查詢某一種 OpenCL \cnglo{device}，也可以查詢所有的。
請參考\reftab{cldevctgr}。

\placetable[here,force][tab:cldevctgr]
{OpenCL 設備種類清單}
{\input{chapter_plf/tbl/tbl_dev_ctgr.tex}}

\carg{num_entries} 是 \carg{devices}中所能容納 \ctype{cl_device} 表項的數目。
如果 \carg{devices} 不是 \cenum{NULL}，則 \carg{num_entries} 必須大於零。

\carg{devices} 用來返回所找到的 OpenCL \cnglo{device}。
\carg{devices} 中返回的 \ctype{cl_device_id} 用來標識一個 OpenCL \cnglo{device}。
如果參數 \carg{devices} 是 \cenum{NULL}，則忽略。
所返回的 OpenCL \cnglo{device}的數目是 \carg{num_entries} 或符合 \ctype{device_type} 的\cnglo{device}数目，取二者中較小的那個。

\carg{num_devices} 返回符合 \ctype{device_type} 的所有 OpenCL \cnglo{device}的數目。
如果 \carg{num_devices} 是 \cenum{NULL}，則忽略。

如果執行成功，則 \capi{clGetDeviceIDs} 會返回 \cenum{CL_SUCCESS}。
否則，返回下列錯誤碼之一：
\startigBase
\item \cenum{CL_INVALID_PLATFORM}，如果 \carg{platform} 無效。
\item \cenum{CL_INVALID_DEVICE_TYPE}，如果 \carg{device_type} 無效。
\item \cenum{CL_INVALID_VALUE}，如果 \carg{num_entries} 等於零且 \carg{devices} 不是 \cenum{NULL}，或者 \carg{num_devices} 和 \carg{devices} 都是 \cenum{NULL}。
\item \cenum{CL_DEVICE_NOT_FOUND}，如果沒有找到任何符合 \carg{device_type} 的 OpenCL \cnglo{device}。
\item \cenum{CL_OUT_OF_RESOURCES}，如果\scdevfailres。
\item \cenum{CL_OUT_OF_HOST_MEMORY}，如果\schostfailres。
\stopigBase

對於 \capi{clGetDeviceIDs} 所返回的 OpenCL \cnglo{device}，\cnglo{app}可以查詢其能力，從而決定使用哪些\cnglo{device}。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%clGetDeviceInfo
函数 \capi{clGetDeviceInfo} 可用來獲取 OpenCL \cnglo{device}的特定信息，如\reftab{cldevquery}所示。
\startclc
cl_int clGetDeviceInfo(
		cl_device_id device,
		cl_device_info param_name,
		size_t param_value_size,
		void *param_value,
		size_t *param_value_size_ret)
\stopclc

\carg{device} 是 \capi{clGetDeviceIDs} 所返回的\cnglo{device}，或者由 \capi{clCreateSubDevices} 創建的\cnglo{subdev}。
如果是\cnglo{subdev}，則返回的是\cnglo{subdev}的信息。

\carg{param_name} 是枚舉常量，用來指明要查詢什麼信息，參見\reftab{cldevquery}。

\carg{param_value} 是指針，所指內存用來存儲 \carg{param_name} 所對應的值（參見\reftab{cldevquery}）。
如果 \carg{param_value} 是 \cenum{NULL}，則忽略。

\carg{param_value_size} 就是 \carg{param_value} 所指內存塊的字節數。
其值必須 >= \reftab{cldevquery}所列返回型別的大小。
 
\carg{param_value_size_ret} 返回 \carg{param_value} 所對應數據的實際大小。
如果 \carg{param_value_size_ret} 是 \cenum{NULL}，則忽略。

\startbuffer[tblcapdevquery]
OpenCL \cnglo{device}查询
\stopbuffer

\splitfloat{
\placetable[here,force][tab:cldevquery]{\getbuffer[tblcapdevquery]}
}{
{\input{chapter_plf/tbl/tbl_dev_query.tex}}
}

無論對於\cnglo{rootdev}（即 \capi{clGetDeviceIDs} 所返回的\cnglo{device}）還是由此創建的\cnglo{subdev}，
\reftab{cldevquery}中所列的查詢都硬返回相同的信息，不過下列查詢例外：
\startigBase
\item \cenum{CL_DEVICE_GLOBAL_MEM_CACHE_SIZE}
\item \cenum{CL_DEVICE_BUILT_IN_KERNELS}
\item \cenum{CL_DEVICE_PARENT_DEVICE}
\item \cenum{CL_DEVICE_PARTITION_TYPE}
\item \cenum{CL_DEVICE_REFERENCE_COUNT}
\stopigBase

如果執行成功，\capi{clGetDeviceInfo} 會返回 \cenum{CL_SUCCESS}；否則，返回下列錯誤碼之一：
\startigBase
\item \cenum{CL_INVALID_DEVICE}——如果 \carg{device} 無效。

\item \cenum{CL_INVALID_VALUE}——如果不支持 \cenum{param_name}，
或者 \cenum{param_value_size} 的值 < \reftab{cldevquery}中返回型別的大小並且 \cenum{param_value} 不是 \cenum{NULL}，
或者 \carg{param_name} 指的是某個擴展，但是此\cnglo{device}不支持相應擴展。

\item \cenum{CL_OUT_OF_RESOURCES}——如果\scdevfailres。
\item \cenum{CL_OUT_OF_HOST_MEMORY}——如果\schostfailres。
\stopigBase

