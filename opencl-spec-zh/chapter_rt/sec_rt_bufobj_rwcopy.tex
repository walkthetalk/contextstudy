\startbuffer[sectitlecreatbufobj]
读、写和拷贝\cnglo{bufobj}
\stopbuffer
\subsection{\getbuffer[sectitlecreatbufobj]}

%%%%%%%%%%%%%%%%%% clEnqueueReadBuffer / clEnqueueWriteBuffer
下列函数所如对的\cnglo{cmd}可以将\cnglo{bufobj}读到\cnglo{host}内存中或
由\cnglo{host}内存写到\cnglo{bufobj}中。
\startclc
cl_int clEnqueueReadBuffer(cl_command_queue command_queue,
			cl_mem buffer,
			cl_bool blocking_read,
			size_t offset,
			size_t cb,
			void *ptr,
			cl_uint num_events_in_wait_list,
			const cl_event *event_wait_list,
			cl_event *event)

cl_int clEnqueueWriteBuffer(cl_command_queue command_queue,
			cl_mem buffer,
			cl_bool blocking_write,
			size_t offset,
			size_t cb,
			const void *ptr,
			cl_uint num_events_in_wait_list,
			const cl_event *event_wait_list,
			cl_event *event)
\stopclc

\carg{command_queue}就是读写\cnglo{cmd}要进入的队列。\carg{command_queue}和
\carg{buffer}必须是由同一个\scopencl\cnglo{context}创建的。

\carg{buffer}是一个有效的\cnglo{bufobj}。

\carg{blocking_read}和\carg{blocking_write}表明读写操作是
{\ftRef 阻塞}的还是{\ftRef 非阻塞}的。

如果\carg{blocking_read}是\cenum{CL_TRUE}，即读命令是阻塞的，\capi{clEnqueueReadBuffer}
会等到buffer数据完全拷贝到\carg{ptr}所指内存中才会返回。

如果\carg{blocking_read}是\cenum{CL_FALSE}，即读命令是非阻塞的，\capi{clEnqueueReadBuffer}
将非阻塞的读命令入队后就会返回。只有等到读命令完成后，才能继续使用\carg{ptr}指向的buffer中的内容。
参数\carg{event}会返回一个\cnglo{evtobj}，可以用来查询读命令的执行情况。读命令完成后，
\cnglo{app}就可以继续使用\carg{prt}所指buffer的内容了。

如果\carg{blocking_write}是\cenum{CL_TRUE}，\scopencl实现会拷贝\carg{prt}所引用的数据，
并将一个写命令入队。当\capi{clEnqueueWriteBuffer}返回后，\cnglo{app}就可以继续使用
\carg{ptr}所指内存了。

如果\carg{blocking_write}是\cenum{CL_FALSE}，\scopencl实现会用\carg{ptr}执行非阻塞的
写操作。既然非阻塞，实现就可以立即返回。返回后\cnglo{app}还不能立刻使用\carg{ptr}所指内存。
参数\carg{event}所返回的\cnglo{evtobj}可以用来查询写命令的执行情况。当写命令完成后，
\cnglo{app}才可以重新使用\carg{prt}所指内存。

\carg{offset}是要读写区域在\cnglo{bufobj}中的偏移量，单位字节。

\carg{cb}是要读写数据的大小，单位字节。

\carg{ptr}指向\cnglo{host}内存中的一个buffer，其中就是要读写的数据。

\carg{event_wait_list}和\carg{num_events_in_wait_list}指定了执行此命令前需要等待哪些事件完成。
如果\carg{event_wait_list}是\cenum{NULL}，则无需等待任何事件，并且\carg{num_events_in_wait_list}必须是0。
如果\carg{event_wait_list}不是\cenum{NULL}，则其中所有事件都必须是有效的，并且\carg{num_events_in_wait_list}必须大于0。
\carg{event_wait_list}中的事件充当同步点，并且与\carg{command_queue}所关联的必须是同一个\cnglo{context}。


