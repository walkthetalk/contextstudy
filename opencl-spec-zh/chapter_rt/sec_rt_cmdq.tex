\section{命令隊列}

OpenCL 對象，如\cnglo{memobj}、\cnglo{programobj}和\cnglo{kernelobj}都是用\cnglo{context}創建的。
使用\cnglo{cmdq}可以在這些對象上面實施運算。
\cnglo{cmdq}可以將一系列運算（叫做\cnglo{cmd}）按序排隊。
如果有多個\cnglo{cmdq}，\cnglo{app}可以將多個相互獨立的\cnglo{cmd}分別排隊而無須同步。
然而這僅在沒有對象被共享時才成立。
如果要在多個\cnglo{cmdq}間共享對象，就要求\cnglo{app}實施相應的同步。
這在\todo{附录A}中會有所描述。

函數 \capi{clCreateCommandQueue} 可用來在某個\cnglo{device}上創建\cnglo{cmdq}。
\startclc
cl_command_queue clCreateCommandQueue(
			cl_context context,
			cl_device_id device,
			cl_command_queue_properties properties,
			cl_int *errcode_ret)
\stopclc

\carg{context} 必須是一個有效的 OpenCL \cnglo{context}。

\startbuffer[tblcmdqprop]
\ctype{cl_command_queue_property}的有效值及其描述
\stopbuffer
\placetable[here,force][tab:clcmdprop]{\getbuffer[tblcmdqprop]}
{\input{chapter_rt/tbl/tbl_cmdq_prop.tex}}

\carg{device} 必須是與 \carg{context} 關聯的\cnglo{device}。
它要麼是用 \capi{clCreateContext} 創建 \carg{context} 時所指定的\cnglo{device}清單中的一個，
要麼其類型與用 \capi{clCreateContextFromType} 創建 \carg{context} 時所指定的\cnglo{device}類型相同。

\carg{properties} 指定了\cnglo{cmdq}的一系列屬性。
它是位域，參見\reftab{clcmdprop}。
其值只能從\reftab{clcmdprop}所列屬性中選取，否則無效。

\carg{errcode_ret} 用來返回錯誤碼。
當然如果 \carg{errcode_ret} 是 \cenum{NULL}，就不會返回錯誤碼了。

如果成功創建了\cnglo{cmdq}，則 \capi{clCreateCommandQueue} 會將其返回，同時將 \carg{errcode_ret} 置為 \cenum{CL_SUCCESS}。
否則返回 \cenum{NULL}，同時將 \carg{errcode_ret} 置為下列錯誤碼之一：
\startigBase
\item \cenum{CL_INVALID_CONTEXT}——如果 \carg{context} 無效。
\item \cenum{CL_INVALID_DEVICE}——如果 \carg{device} 無效或沒有與 \carg{context} 關聯。
\item \cenum{CL_INVALID_VALUE}——如果 \carg{properties} 的值有效，但是此\cnglo{device}不支持。
\item \cenum{CL_INVALID_QUEUE_PROPERTIES}——如果\carg{properties}的值没问题，但是\carg{device}不支持。
\item \cenum{CL_OUT_OF_RESOURCES}——如果\scdevfailres。
\item \cenum{CL_OUT_OF_HOST_MEMORY}——如果\schostfailres。
\stopigBase

%clRetainCommandQueue
函数\capi{clRetainCommandQueue}会使\carg{command_queue}的\cnglo{refcnt}加1。
\startclc
cl_int clRetainCommandQueue(
		cl_command_queue command_queue)
\stopclc

如果执行成功，\capi{clRetainCommandQueue}会返回\cenum{CL_SUCCESS}。否则，返回下列错误码之一：
\startigBase
\item \cenum{CL_INVALID_COMMAND_QUEUE}——如果\carg{command_queue}无效。
\item \cenum{CL_OUT_OF_RESOURCES}——如果\scdevfailres。
\item \cenum{CL_OUT_OF_HOST_MEMORY}——如果\schostfailres。
\stopigBase

\capi{clCreateCommandQueue}会执行隐式的\englo{retain}。这对第三方库非常有用，使其可以直
接获取由\cnglo{app}传给它们的\cnglo{cmdq}。然而，\cnglo{app}可能会在没有通知库的情况下删
除\cnglo{cmdq}。允许函数\englo{retain}或\englo{release}\cnglo{cmdq}，在库所使用的
\cnglo{cmdq}不再有效时就不会出现问题。

函数\capi{clReleaseCommandQueue}会使\carg{command_queue}的\cnglo{refcnt}减1。
\startclc
cl_int clReleaseCommandQueue(
		cl_command_queue command_queue)
\stopclc

如果执行成功，\capi{clRetainCommandQueue}会返回\cenum{CL_SUCCESS}。否则，返回下列错误码之一：
\startigBase
\item \cenum{CL_INVALID_COMMAND_QUEUE}——如果\carg{command_queue}无效。
\item \cenum{CL_OUT_OF_RESOURCES}——如果\scdevfailres。
\item \cenum{CL_OUT_OF_HOST_MEMORY}——如果\schostfailres。
\stopigBase

当\carg{command_queue}的\cnglo{refcnt}变为0，并且其中的所有\cnglo{cmd}全部完成后
（如执行\cnglo{kernel}、更新\cnglo{memobj}等），此\cnglo{cmdq}就会被删除。

\capi{clReleaseCommandQueue}会执行隐式的刷新，这会执行之前入队的\scopencl\cnglo{cmd}。

函数\capi{clGetCommandQueueInfo}可以用来查询\cnglo{cmdq}的信息。
\startclc
cl_int clGetCommandQueueInfo(
		cl_command_queue command_queue,
		cl_command_queue_info param_name,
		size_t param_value_size,
		void *param_value,
		size_t *param_value_size_ret)
\stopclc

\carg{command_queue}指定要查询哪个\cnglo{cmdq}。

\carg{param_name}指定要查询什么信息。

\carg{param_value}指向的内存用来存储查询结果。如果是\cenum{NULL}，则被忽略。

\carg{param_value_size}即\carg{param_value}所指内存的大小（单位：字节）。其值必须大于等于\reftab{cmdqinfo}中返回类型的大小。如果是\cenum{NULL}，则被忽略。

\carg{param_value_size_ret}返回\carg{param_value}中所返回信息的实际大小。如果是\cenum{NULL}，则被忽略。

\capi{clGetCommandQueueInfo}所支持的\carg{param_name}的值和\carg{param_value}中所返回的信息如\reftab{cmdqinfo}所示。

\cltable
{\placetable[here,force][tab:cmdqinfo]{\capi{clGetCommandQueueInfo}所支持的\carg{param_names}清单}}
{\input{tbl/tbl_cmdq_getinfo.tex}}

如果执行成功，\capi{clGetCommandQueueInfo}会返回\cenum{CL_SUCCESS}。否则，返回下列错误码之一：
\startigBase
\item \cenum{CL_INVALID_COMMAND_QUEUE}——如果\carg{command_queue}无效。
\item \cenum{CL_INVALID_VALUE}——如果\carg{param_name}不在支持之列，或者
      \carg{param_value_size}的值小于\reftab{cmdqinfo}中返回类型的大小并且
      \carg{param_value}不是\cenum{NULL}。
\item \cenum{CL_OUT_OF_RESOURCES}——如果\scdevfailres。
\item \cenum{CL_OUT_OF_HOST_MEMORY}——如果\schostfailres。
\stopigBase

注意，当创建了\cnglo{context}和\cnglo{cmdq}并且已经有\cnglo{cmd}入队了，这时候它们所使用的\cnglo{device}可能变的不可用了。这种情况下，对于使用这个\cnglo{context}（和\cnglo{cmdq}）的\scopenclapi而言，其行为\cnglo{impdef}。在\cnglo{device}变的不可用时，如果创建\cnglo{context}时用户指定了回调函数，则可以在传递给它的参数\carg{errinfo}、\carg{private_info}中记录相应的信息。

