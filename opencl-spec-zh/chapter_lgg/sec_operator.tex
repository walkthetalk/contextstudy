\section{運算子}

\startigBig
% arithmetic operator
\startitem
算術運算子加（\ccmm{+}）、減（\ccmm{-}）、乘（\ccmm{*}）、除（\ccmm{/}）
都可以在內建的整數、浮點數標量和矢量數據型別上進行運算。
而模除（\ccmm{\%}）則只能在內建的整數標量和整數矢量數據型別上進行運算。
在運算子的型別轉換後，所有算術運算子所返回的結果都與運算子具有相同的型別，
且都是某種內建型別（整數或浮點數）。
轉換後，有如下情況：
\startigBase
\item 兩個運算子都是標量。這種情況下，運算結果也是標量。

\item 一個運算子是標量，另一個是矢量。
這種情況下，會對標量運算子進行算術轉換，使其型別與矢量運算子的元素型別相同。
然後將標量運算子擴展成矢量，其構件數目與矢量運算子相同。
最後按構件逐一進行運算，結果是同樣大小的矢量。

\item 兩個運算子都是矢量，且型別相同。
這種情況下，會按構件逐一進行運算，結果是同樣大小的矢量。
\stopigBase

任何其他情況下的隱式轉換都是違規的。
對於整數型別的除法，如果結果無法用此型別表示，即發生了溢出（上溢或下溢），
並不會引起異常，但結果的值沒有指定。這跟整數除以零的效果一樣。
而浮點數除以零則會導致 \math{\pm\infty} 或 NaN，
就像 IEEE-754 標準中所規定的那樣。
內建函式 \capi{dot} 和 \capi{cross} 分別為矢量點乘和矢量叉乘。
\stopitem

% unary operator
\item 算術單元運算子（\ccmm{+} 和 \ccmm{-}）可在內建標量和矢量類型上進行運算。

% pre/post-increment/decrement operator
\item 算術運算子中的後置式或前置式遞增和遞減運算子可以在內建的標量和矢量型別上進行運算，
但內建的標量和矢量浮點型別除外\footnote{
在浮點數上使用前置式和後置式遞增運算子時可能會導致意料之外的行為，
因此 OpenCL 中不支持對浮點標量和矢量型別運用此運算子。
例如，如果一個變量為浮點型別，其值為 \ccmm{0x1.0p25f}，
 \ccmm{a++} 返回的還是 \ccmm{0x1.0p25f}。
同時，如果 \cvar{a} 中含有小數，不保證 \ccmm{(a++)--} 會返回 \ccmm{a}。
如果不是缺省的舍入模式，
則 \ccmm{(a++)--} 的結果可能跟 \ccmm{a++} 或 \ccmm{a--} 的結果相同。}。
所有單元運算子都會在運算元的所有構件上進行運算。結果的型別與運算元的型別相同。
對於後置式或前置式遞增和遞減運算子，算式必須是可賦值的（即左值）。
前置式遞增或前置式遞減運算子會對所操作算式的內容加 1 或減 1，整個算式的值就是修改後的值。
而後置式遞增或後置式遞減運算子也會對所操作算式的內容加 1 或減 1，但整個算式的值是修改前的值。

% relational operator
\startitem
關係運算子\footnote{
對於矢量關係運算，結果也是矢量，
要想知道其中的元素是否有 \ccmm{true} 或者是否所有元素都是 \ccmm{true}，
例如，在 \ccmm{if ()} 語句的上下文中使用，
請查閱\todo{6.11.6}中的內建函式 \capi{any} 和 \capi{all}。}
大於（\ccmm{>}）、小於（\ccmm{<}）、大於等於（\ccmm{>=}）、
小於等於（\ccmm{<=}）可在標量或矢量型別上進行運算。
所有關係運算子的結果都是整數型別。在對運算子進行型別轉換後，有如下情況：
\startigBase
\item 兩個運算子都是標量。這種情況下，運算結果是 \ctype{int} 標量。

\item 一個運算子是標量，另一個是矢量。
這種情況下，會對標量運算子進行算術轉換，使其型別與矢量運算子的元素型別相同。
然後將標量運算子擴展成矢量，其構件數目與矢量運算子相同。
最後按構件逐一進行運算，結果是同樣大小的矢量。

\item 兩個運算子都是矢量，且型別相同。
這種情況下，會按構件逐一進行運算，結果是同樣大小的矢量。
\stopigBase

任何其他情況下的隱式轉換都是違規的。
如果運算元都是標量，則結果是標量帶符號整數型別 \ctype{int}。
而如果運算元都是矢量型別，則結果是矢量帶符號整數型別，其元素數目與運算元相同。
如果矢量運算元的元素型別為 \cldtv{char} 和 \cldtv{uchar}，則結果為 \cldtv{char}。
如果矢量運算元的元素型別為 \cldtv{short} 和 \cldtv{ushort}，則結果為 \cldtv{short}。
如果矢量運算元的元素型別為 \cldtv{int}、 \cldtv{uint} 和 \cldtv{float}，則結果為 \cldtv{int}。
如果矢量運算元的元素型別為 \cldtv{long}、 \cldtv{ulong} 和 \cldtv{double}，則結果為 \cldtv{long}。
對於標量型別的關係運算，如果所指定的關係為 \ccmm{false} 則結果為 \ccmm{0}，否則結果為 \ccmm{1}。
對於矢量型別的關係運算，如果所指定的關係為 \ccmm{false} 則結果為 \ccmm{0}，否則結果為 \ccmm{-1} （即設置了所有位）。
如果任一引數不是數字（NaN），則關係運算子的結果就為 \ccmm{0}。
\stopitem

% equality operator
\startitem
等號運算子\footnote{
對於矢量關係運算，結果也是矢量，
要想知道其中的元素是否有 \ccmm{true} 或者是否所有元素都是 \ccmm{true}，
例如，在 \ccmm{if ()} 語句的上下文中使用，
請查閱\todo{6.11.6}中的內建函式 \capi{any} 和 \capi{all}。}
相等（\ccmm{==}）、不等（\ccmm{!=}）可對所有內建標量和矢量型別進行運算。
所有等號運算子的結果均為整數型別。
在對運算子進行型別轉換後，有如下情況：
\startigBase
\item 兩個運算子都是標量。這種情況下，運算結果也是標量。

\item 一個運算子是標量，另一個是矢量。
這種情況下，會對標量運算子進行算術轉換，使其型別與矢量運算子的元素型別相同。
然後將標量運算子擴展成矢量，其構件數目與矢量運算子相同。
最後按構件逐一進行運算，結果是同樣大小的矢量。

\item 兩個運算子都是矢量，且型別相同。
這種情況下，會按構件逐一進行運算，結果是同樣大小的矢量。
\stopigBase

任何其他情況下的隱式轉換都是違規的。
如果運算元都是標量，則結果是標量帶符號整數型別 \ctype{int}。
而如果運算元都是矢量型別，則結果是矢量帶符號整數型別，其元素數目與運算元相同。
如果矢量運算元的元素型別為 \cldtv{char} 和 \cldtv{uchar}，則結果為 \cldtv{char}。
如果矢量運算元的元素型別為 \cldtv{short} 和 \cldtv{ushort}，則結果為 \cldtv{short}。
如果矢量運算元的元素型別為 \cldtv{int}、 \cldtv{uint} 和 \cldtv{float}，則結果為 \cldtv{int}。
如果矢量運算元的元素型別為 \cldtv{long}、 \cldtv{ulong} 和 \cldtv{double}，則結果為 \cldtv{long}。
對於標量型別的等號運算，如果所指定的關係為 \ccmm{false} 則結果為 \ccmm{0}，否則結果為 \ccmm{1}。
對於矢量型別的等號運算，如果所指定的關係為 \ccmm{false} 則結果為 \ccmm{0}，否則結果為 \ccmm{-1} （即設置了所有位）。
如果任一引數不是數字（NaN），則相等運算子（\ccmm{==}）的結果就為 \ccmm{0}。
如果任一引數不是數字（NaN），
則不等運算子（\ccmm{!=}）的結果就為 \ccmm{1} （對於標量運算元）
或 \ccmm{-1} （對於矢量運算元）。
\stopitem

% bitwise operator
\startitem
位元運算子與（\ccmm{&}）、或（\ccmm{|}）、異或（\ccmm{^}）、非（\ccmm{~}）
可以對所有內建的標量或矢量型別進行運算，但是浮點型別除外（無論標量還是矢量）。
對於矢量內建型別，這些運算子會按構件逐一運算。
如果一個運算子為標量，而另一個是矢量，
則會對標量運算子進行算術轉換，使其型別與矢量運算子的元素型別相同。
然後將標量運算子擴展成矢量，其構件數目與矢量運算子相同。
最後按構件逐一進行運算，結果是同樣大小的矢量。
\stopitem

% logical operator
\startitem
邏輯運算子與（\ccmm{&&}）、或（\ccmm{||}）可對所有內建標量或矢量型別進行運算。
對於內建的標量型別，
如果左手的運算元不等於 0，則邏輯與運算子（\ccmm{&&}）只對右手的運算子進行求值。
對於內建的標量型別，
如果左手的運算元不等於 0，則邏輯或運算子（\ccmm{||}）只對右手的運算子進行求值。
對於內建的矢量型別，
會對兩個運算子都求值，並按構件逐一進行運算。
如果一個運算子是標量，另一個是矢量，
則會對標量運算子進行算術轉換，使其型別與矢量運算子的元素型別相同。
然後將標量運算子擴展成矢量，其構件數目與矢量運算子相同。
最後按構件逐一進行運算，結果是同樣大小的矢量。

邏輯異或運算子（\ccmm{^^}）是保留關鍵字。

如果運算元都是標量，則結果是標量帶符號整數型別 \ctype{int}。
而如果運算元都是矢量型別，則結果是矢量帶符號整數型別，其元素數目與運算元相同。
如果矢量運算元的元素型別為 \cldtv{char} 和 \cldtv{uchar}，則結果為 \cldtv{char}。
如果矢量運算元的元素型別為 \cldtv{short} 和 \cldtv{ushort}，則結果為 \cldtv{short}。
如果矢量運算元的元素型別為 \cldtv{int}、 \cldtv{uint} 和 \cldtv{float}，則結果為 \cldtv{int}。
如果矢量運算元的元素型別為 \cldtv{long}、 \cldtv{ulong} 和 \cldtv{double}，則結果為 \cldtv{long}。

對於標量型別的邏輯運算，如果所指定的關係為 \ccmm{false} 則結果為 \ccmm{0}，否則結果為 \ccmm{1}。
對於矢量型別的邏輯運算，如果所指定的關係為 \ccmm{false} 則結果為 \ccmm{0}，否則結果為 \ccmm{-1} （即設置了所有位）。
\stopitem

% logical unary operator
\startitem
邏輯單元運算子非（\ccmm{!}）可對所有內建標量或矢量型別進行運算。
對於內建矢量型別，會按構件逐一運算。

如果運算元是標量，則結果是標量帶符號整數型別 \ctype{int}。
而如果運算元是矢量型別，則結果是矢量帶符號整數型別，其元素數目與運算元相同。
如果矢量運算元的元素型別為 \cldtv{char} 和 \cldtv{uchar}，則結果為 \cldtv{char}。
如果矢量運算元的元素型別為 \cldtv{short} 和 \cldtv{ushort}，則結果為 \cldtv{short}。
如果矢量運算元的元素型別為 \cldtv{int}、 \cldtv{uint} 和 \cldtv{float}，則結果為 \cldtv{int}。
如果矢量運算元的元素型別為 \cldtv{long}、 \cldtv{ulong} 和 \cldtv{double}，則結果為 \cldtv{long}。

對於標量型別的邏輯非運算，如果運算元不等於 0 則結果為 \ccmm{0}，否則結果為 \ccmm{1}。
對於矢量型別的邏輯非運算，如果運算元不等於 0 則結果為 \ccmm{0}，否則結果為 \ccmm{-1} （即設置了所有位）。
\stopitem

% ternary selection operator
\startitem
三元選擇運算子（\ccmm{?:}）會在三個算式上進行運算（\ccmm{exp1 ? exp2 : exp3}）。
此運算子會先對 \ccmm{exp1} 進行求值，結果可能是標量或矢量，但不會是浮點數。
如果結果是標量，且不等於 0，那麼接着對第二個算式進行求值，否則對第三個算式求值。
如果結果是矢量，則等同於調用 \capi{select}\ccmm{(exp3, exp2, exp1)}。
函式 \capi{select} 在\todo{表 6.14}中有所描述。
第二個和第三個算式的結果可以是任意型別，只要型別匹配即可；
如果不匹配，則會進行隱式轉換（參見\refsec{implicityConversion}）使其匹配；
而如果一個是矢量，另一個是標量，則會對標量進行算術轉換，使其型別與矢量運算元的元素型別相同，
然後將其擴展成型別與矢量運算元相同的矢量。
其結果的型別就是整個算式的型別。
\stopitem

% right-shift and left-shift
\startitem
運算子右移（\ccmm{>>}）和左移（\ccmm{<<}）可對所有內建的標量或矢量型別進行運算，
但浮點型別除外。
對於內建的矢量型別，會按構件逐一進行運算。
對於右移運算子（\ccmm{>>}）和左移運算子（\ccmm{<<}），
如果第一個運算元是標量，則最右邊的運算元也必須是標量；
如果第一個運算元是矢量，則最右邊的運算元即可以是矢量，也可以是標量。

\ccmm{E1 << E2} 的結果就是將 \ccmm{E1} 左移 \ccmm{x} 位，
 \ccmm{x} 等於將 \ccmm{E2} 視為無符號整數時其低 \math{log_{2}N} 位的值；
如果 \ccmm{E1} 是標量，則 \ccmm{N} 就是在型別晉陞\footnote{
整數的型別晉陞在 ISO/IEC 9899: 1999 的節 6.3.1.1 中有所描述。}
後，表示 \ccmm{E1} 的數據型別所用的位數，
如果 \ccmm{E1} 是矢量，則 \ccmm{N} 為表示 \ccmm{E1} 的元素所用的位數。
騰出的位元會填零。

\ccmm{E1 >> E2} 的結果就是將 \ccmm{E1} 右移 \ccmm{x} 位，
 \ccmm{x} 等於將 \ccmm{E2} 視為無符號整數時其低 \math{log_{2}N} 位的值；
如果 \ccmm{E1} 是標量，則 \ccmm{N} 就是在型別晉陞後，表示 \ccmm{E1} 的數據型別所用的位數，
如果 \ccmm{E1} 是矢量，則 \ccmm{N} 為表示 \ccmm{E1} 的元素所用的位數。
如果 \ccmm{E1} 是無符號型別，或者是帶符號型別但其值非負，則騰出的位元會填零。
如果 \ccmm{E1} 是帶符號型別，且是負值，則騰出的位元會填一。
\stopitem

% sizeof

\stopigBig
