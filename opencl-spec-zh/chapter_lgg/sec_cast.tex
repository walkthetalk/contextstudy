% Conversions and Type Casting
\section{轉換以及轉型}

% Implicit Conversions
\subsection{隱式轉換}

OpenCL 支持\reftab{builtInScalarDataTypes}中所定義的內建標量類型間的隱式轉換
（\ctype{void} 和 \ctype{half}\footnote{如果支持擴展 \clext{cl_khr_fp16}，
則 \ctype{half} 也在支持之列。} 除外）。
隱式轉換不僅是對表達式值的重釋（reinterpret），同時會將其轉換成另一個類型與其相等的值。
例如，可以將整數 \ccmm{5} 轉換成浮點數 \ccmm{5.0}。

對於內建矢量數據類型，不允許進行隱式轉換。

對於指針類型的隱式轉換遵循 C99 規範中所描述的規則。

% Explicit Casts
\subsection{顯式轉型}

對於\reftab{builtInScalarDataTypes}中所定義的內建標量類型，
標準的轉型動作會實施恰當的轉換
（\ctype{void} 和 \ctype{half}\footnote{如果支持擴展 \clext{cl_khr_fp16}，
則 \ctype{half} 也在支持之列。} 除外）。下面例子中：
\startclc
float	f = 1.0f;
int	i = (int)f;
\stopclc
\cvar{f} 存儲的是 \ccmm{0x3F800000}，而 \cvar{i} 存儲的是 \ccmm{0x1}，
即將 \cvar{f} 中的浮點數 \ccmm{1.0f} 轉換成了整數值。

對於矢量類型的顯式轉型是非法的。下面的例子會導致編譯錯誤。
\startclc
int4	i;
uint4	u = (uint4) i;	<- not allowed

float4	f;
int4	i = (int4) f;	<- not allowed

float4	f;
int8	i = (int8) f;	<- not allowed
\stopclc

標量到矢量的轉換可以通過轉型來實施。
轉型同時會實施恰當的算數轉換。
轉換成內建整形矢量時會向零舍入。
轉換成浮點矢量時會使用缺省的舍入模式。
將 \ctype{bool} 轉型成整形矢量時，
如果 \ctype{bool} 值是 \cenum{true}，會將矢量構件置為 \math{-1} （即設置了所有位），
否則將矢量構件置為 \math{0}。

下面是顯式轉型的一些正確示例。
\startclc
loat	f = 1.0f;
float4	va = (float4)f;
// va is a float4 vector with elements (f, f, f, f).

uchar	u = 0xFF;
float4	vb = (float4)u;
// vb is a float4 vector with elements((float)u, (float)u,
//                                     (float)u, (float)u).

float	f = 2.0f;
int2	vc = (int2)f;
// vc is an int2 vector with elements ((int)f, (int)f).

uchar4	vtrue = (uchar4)true;
// vtrue is a uchar4 vector with elements (0xff, 0xff,
//                                         0xff, 0xff).
\stopclc

% Explicit Conversions
\subsection{顯式轉換}

下面一組函數可用來實施顯式轉換
\startclc
convert_destType(sourceType)
\stopclc
這組函數可以支持所有所支持類型（參加\refsec{bisdt}、\refsec{bivdt}和\refsec{obidt}）
間的類型轉換，這些類型除外：
 \ctype{bool}、 \ctype{half}、 \ctype{size_t}、 \ctype{ptrdiff_t}、
 \ctype{intptr_t}、 \ctype{uintptr_t} 和 \ctype{void}。

源矢量和目的矢量的元素數目必須一樣。

下面例子中：
\startclc
uchar4	u;
int4	c = convert_int4(u);
\stopclc
\capi{convert_int4}
 將 \ctype{uchar4} 矢量 \cvar{u} 轉換成了 \ctype{int4} 矢量 \cvar{c}。

\startclc
float	f;
int	i = convert_int(f);
\stopclc
\capi{convert_int}
 將 \ctype{float} 標量 \cvar{f} 轉換成了 \ctype{int} 標量 \cvar{i}。

可以通過兩個可選的修飾符（modifier）來改變轉換的行為，
其中一個修飾符可以對溢出的輸入使用飽和算法（saturation），另一個可以指定舍入模式。

完整的標量轉換函數形如：
\startclc
destType convert_destType<_sat><_roundingMode> (sourceType)
\stopclc

完整的矢量轉換函數形如：
\startclc
destTypen convert_destTypen<_sat><_roundingMode> (sourceTypen)
\stopclc

% Data Types
\subsubsection{數據類型}

對於標量類型 \ctype{char}、 \ctype{uchar}、 \ctype{short}、 \ctype{ushort}、
 \ctype{int}、 \ctype{uint}、 \ctype{long}、 \ctype{ulong}、 \ctype{float}
 以及由此所衍生的內建矢量類型，都可以進行轉換。
運算元和結果的類型中所含元素的數目必須相同。
運算元和結果的類型可能相同，這種情況下不會進行轉換，表達式的類型和值都不變。

整數之間的轉換遵循 C99 規範的節 6.3.1.1 和節 6.3.1.3 中的轉換規則，
不過\refsec{oorbasc}中所描述的溢出行為和飽和轉換例外。

% Rounding Modes
\subsubsection{舍入模式}

與浮點類型有關的轉換會按照 IEEE-754 中的舍入規則進行舍入。
轉換可以使用\reftab{roundingModes}中的修飾符指定舍入模式。

\placetable[here,force][tab:roundingModes]
{舍入模式}
{\input{chapter_lgg/tbl/tbl_roundingmodes.tex}}

默認情況下，轉換成整形時使用舍入模式 \ccmm{_rtz}，而轉換成浮點類型
\footnote{轉換成浮點格式時，如果源的值超過了目標類型所能表示的最大有限浮點值，
舍入模式會影響轉換結果，根據 IEEE-754 的舍入規則來確定結果是最大有限浮點值，
還是和源有相同正負號的無窮值。}
時使用缺省的舍入模式。
所支持的唯一一個缺省的浮點舍入模式是向最近偶數舍入，
即浮點類型的缺省舍入模式是 \ccmm{_rte}。

% Out-of-Range Behavior and Saturated Conversions
\subsubsection[sec:oorbasc]{溢出行為和飽和轉換}

轉換時，如果運算元大於目標類型所能表示的最大值，或者小於目標類型所能表示的最小值，就認為是溢出。
其結果由 C99 規範的節 6.3 中的轉換規則來確定。
如果要將浮點類型轉換成整形，則其行為\cnglo{impdef}。

轉換成整形時可以使用飽和模式（在轉換函數的名字後面加上修飾符 \ccmm{_sat}）。
此模式下，如果發生溢出，結果將是目標格式所能表示的值中與源運算元最近的那個
（會將 NaN 轉換成 0）。

轉換成浮點類型時將遵循 IEEE-754 中的舍入規則。
轉換成浮點格式時不能使用修飾符 \ccmm{_sta}。

% Explicit Conversion Examples
\subsubsection{顯式轉換的例子}

\startexample
\startclc
short4	s;

// negative values clamped to 0
ushort4	u = convert_ushort4_sat( s );

// values > CHAR_MAX converted to CHAR_MAX
// values < CHAR_MIN converted to CHAR_MIN
char4 c = convert_char4_sat( s );
\stopclc
\stopexample

\startexample
\startclc
float4 f;

// values implementation defined for
// f > INT_MAX, f < INT_MIN or NaN
int4	i = convert_int4( f );

// values > INT_MAX clamp to INT_MAX, values < INT_MIN clamp
// to INT_MIN. NaN should produce 0.
// The _rtz rounding mode is used to produce the integer values.
int4	i2 = convert_int4_sat( f );

// similar to convert_int4, except that floating-point values
// are rounded to the nearest integer instead of truncated
int4	i3 = convert_int4_rte( f );

// similar to convert_int4_sat, except that floating-point values
// are rounded to the nearest integer instead of truncated
int4	i4 = convert_int4_sat_rte( f );
\stopclc
\stopexample

\startexample
\startclc
int4	i;

// convert ints to floats using the default rounding mode.
float4 f = convert_float4( i );

// convert ints to floats. integer values that cannot
// be exactly represented as floats should round up to the
// next representable float.
float4 f = convert_float4_rtp( i );
\stopclc
\stopexample

% Reinterpreting Data As Another Type
\subsection{將數據重釋為其他類型}

在 OpenCL 中，經常有需要將某一種數據類型重釋為另一種數據類型。
在需要直接訪問浮點類型中的位元時就需要這樣做，
例如，屏蔽掉（mask off）浮點數據的符號位，
或者使用浮點矢量關係運算符的結果（參加\todo{6.3.d}）
\footnote{另外，對於一些設計用來支持特定矢量 ISA
（如 AltiVec\high{TM}、 CELL Broadband Engine\high{TM} 架構）的 C 語言擴展，
會將這樣的轉換與重排運算符（swizzle oprator）一起使用對類型進行還原（unconversion）。
為支持這種遺留代碼， \capi{as_typen()} 允許在大小相同但元素數目不同的矢量間進行轉換，
即使這種轉換的行為不能移植到其他硬件架構的 OpenCL 實現上。
 AltiVec\high{TM} 是 Motorola Inc. 的商標。
 Cell Broadband Engine 是 Sony Computer Entertainment Inc. 的商標。}。
對於這種（反）轉換， C 語言中經常使用的有這幾種方法：
指針別名（pointer aliasing）、聯合體（union）和 內存拷貝（memcpy）。
對於 C99，這些方法中只有內存拷貝是嚴格正確的。
由於 OpenCL 沒有提供 \capi{memcpy}，所以需要其他手段。


