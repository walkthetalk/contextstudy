\section{所支持的數據類型}

所支持的數據類型如下所示。

% Built-in Scalar Data Types
\subsection[sec:bisdt]{內建標量數據類型}

\reftab{builtInScalarDataTypes}中列出了內建的標量數據類型。

\splitfloat{
\placetable[here,force][tab:builtInScalarDataTypes]
{內建標量數據類型}
}{
{\input{chapter_lgg/tbl/tbl_bisdt.tex}}
}

在 OpenCL API（以及頭文件）中，大多數內建標量類型都被聲明為其他類型，
以更好的為\cnglo{app}所用。
下表列出了 OpenCL C 編程語言中的內建標量數據類型與\cnglo{app}所用類型間的對應關係。

\input{chapter_lgg/tbl/tbl_bisdt2appdt.tex}

\subsubsection{數據類型 \cldts{half}}

數據類型 \cldts{half} 必須符合 IEEE 754-2008。
類型為 \cldts{half} 的數含有 1 個符號位， 5 個指數位以及 10 個尾數位。
符號、指數、尾數的含義與 IEEE 754 浮點數類似。
指數偏置值為 15。
數據類型 \cldts{half} 必須能夠表示有限規格化數，去規格化數，無限以及 NaN。
不能將 \cldts{half} 類型的去規格化數
（可能是用 vstore_half 將 \cldts{float} 變換成 \cldts{half} 時生成的，
也可能是用 vload_half 將 \cldts{half} 變換成 \cldts{float} 時生成的）刷成 0。
從 \cldts{float} 到 \cldts{half} 的變換會將尾數舍入成 11 位精度。
從  \cldts{half} 到 \cldts{float} 的變換是無損的；
所有 \cldts{half} 數都可精確地表示成 \cldts{float} 值。

數據類型 \cldts{half} 只能用來聲明含有 \cldts{half} 值的緩存指針。
下面是幾個例子。
\startclc
void bar (__global half *p)
{
	....
}
__kernel void foo (__global half *pg, __local half *pl)
{
	__global half *ptr;
	int offset;

	ptr = pg + offset;
	bar(ptr);
}
\stopclc

下面的例子是對類型 \cldts{half} 的不當應用：
\startclc
half a;
half b[100];

half *p;
a = *p;		<- not allowed. must use vload_half function
\stopclc

函數 \capi{vload_half}、 \capi{vload_halfn}、 \capi{vloada_halfn}
 和 \capi{vstore_half}、 \capi{vstore_halfn}、 \capi{vstorea_halfn}
 可分別裝載和存儲 \cldts{half} 指針，參見\todo{6.12.7}。
裝載函數可從內存中讀取標量或矢量 \cldts{half} 值 並將其變換成 \cldts{float} 值。
而存儲函數則將標量或矢量 \cldts{float} 值作為輸入，並（以恰當的舍入模式）
將其變換成 \cldts{half} 標量或矢量值後寫入內存中。


% Built-in Vector Data Types
\subsection[sec:bivdt]{內建矢量數據類型
\footnote{對於這些內建的矢量數據類型，即使下層的計算設備不支持， OpenCL 實現也要支持。
設備編譯器需要將這些類型翻譯成恰當的指令，以計算設備原生支持的內建類型。
\todo{附錄 B} 描述了矢量類型所含構件在內存中的順序。}}

支持的矢量數據類型有： \cldts{char}、 \cldts{unsigned char}、 \cldts{short}、
 \cldts{unsigned short}、 \cldts{integer}、 \cldts{unsigned integer}、
 \cldts{long}、 \cldts{unsigned long}、 \cldts{float}。
矢量數據類型是通過在類型名（即 \cldts{char}、 \cldts{uchar}、 \cldts{short}、
 \cldts{ushort}、 \cldts{int}、 \cldts{uint}、 \cldts{float}、 \cldts{long}、
 \cldts{ulong}）後面跟一個常值 \math{n} 來定義的
（其中 \math{n} 表示矢量元素的數目）。
對於所有矢量數據類型而言，這個 \math{n} 可以是 2、 3、 4、 8 和 16。

\reftab{builtInVectorDataTypes}中列出了內建的矢量數據類型。

\placetable[here,force][tab:builtInVectorDataTypes]
{內建矢量數據類型}
{\input{chapter_lgg/tbl/tbl_bivdt.tex}}

在 OpenCL API（以及頭文件）中，大多數內建矢量類型都被聲明為其他類型，
以更好的為\cnglo{app}所用。
下表列出了 OpenCL C 編程語言中的內建矢量數據類型與\cnglo{app}所用類型間的對應關係。

\input{chapter_lgg/tbl/tbl_bivdt2appdt.tex}

% Other Built-in Data Types
\subsection[sec:obidt]{其他內建數據類型}

\reftab{otherBuiltInDataTypes}中列出了 OpenCL 所支持的其他內建數據類型。

\placetable[here,force][tab:otherBuiltInDataTypes]
{其他內建數據類型}
{\input{chapter_lgg/tbl/tbl_obidt.tex}}

注意：

只有當\cnglo{device}支持圖像時
（即 \cenum{CL_DEVICE_IMAGE_SUPPORT} 是 \cenum{CL_TRUE}，參見\reftab{cldevquery}），
才會定義類型 \cldts{image2d_t}、 \cldts{image3d_t}、 \cldts{image2d_array_t}、
 \cldts{image1d_t}、 \cldts{image1d_buffer_t}、 \cldts{image1d_array_t}、
 \cldts{sampler_t}。

C99 的衍生類型（數組、結構體、聯合體、函數以及指針）也在支持之列，
不過必須是由\refsec{bisdt}、\refsec{bivdt}
和\refsec{obidt}中所描述的內建數據類型所構造的，
同時有\refsec{restrictions}中所描述的限制。

% Reserved Data Types
\subsection{保留的數據類型}

\reftab{reservedDataTypes} 中所列的數據類型名都是保留的，
\cnglo{app}不能將其作為類型名使用。
對於\reftab{builtInVectorDataTypes} 中所列的矢量數據類型名而言，
當 \math{n} 是除 2、 3、 4、 8 和 16 之外的其他值時，也是保留的。

\splitfloat{
\placetable[here,force][tab:reservedDataTypes]
{保留的數據類型}
}{
{\input{chapter_lgg/tbl/tbl_reserveddatatypes.tex}}
}

% Alignment of Types
\subsection{類型對齊}

內存中所聲明的數據項會按起類型的字節數進行對齊。
例如，類型為 \cldts{float4} 的變量會對齊到 16 字節邊界；
而 \cldts{char2} 則會對齊到 2 字節邊界。

對於具備 3 個構件的矢量數據類型，其大小為 \math{4 \times sizeof(component)}。
這意味着此類型會按 \math{4 \times sizeof(component)} 進行對齊。
內建函數 \capi{vload3} 和 \capi{vstore3} 可用來讀寫這種數據。

如果內建數據類型的大小不是二的冪，則按相鄰較大的二的冪進行對齊。
此規則僅對內建類型有效，不會作用於結構體或聯合體上。

OpenCL 編譯器負責數據項的對齊。
如果 \cqlf{__kernel} 函數的參數聲明為某種數據類型的指針，
那麼 OpenCL 編譯器就可以假定這個指針已經按照相應數據類型的要求進行了對齊。
如果裝載或存儲時沒有對齊，則其行為是未定義的，
\todo{6.12.7}中定義的函數 \clapiv{vload}、 \clapiv{vload_half}、
 \clapiv{vstore} 和 \clapiv{vstore_half} 例外。
矢量裝載函數可以從已經按矢量元素類型對齊的地址中讀取矢量數據。
矢量存儲函數可以將矢量數據寫入已經按矢量元素類型對齊的地址中。

% Vector Literals
\subsection{常值矢量}

可使用常值矢量由一組標量、矢量或其混合體來創建矢量。
常值矢量可用來對矢量進行初始化，也可以用作主表達式。
常值矢量不能用作左值（L-value）。

常值矢量的書寫形式：一個帶括號的矢量類型，緊跟一組帶括號參數，參數以逗號分隔。
常值矢量像重載的函數一樣參與運算。
這個函數的參數類型就是最終矢量中的元素類型，參數個數就是最終矢量中的元素個數。
另外，還有一種形式只帶有一個標量，其類型與最終矢量中的元素類型一樣。
例如， \ctype{float4} 有下列形式：
\startclc
(float4)( float, float, float, float )
(float4)( float2, float, float )
(float4)( float, float2, float )
(float4)( float, float, float2 )
(float4)( float2, float2 )
(float4)( float3, float )
(float4)( float, float3 )

(float4)( float )
\stopclc

除了按照函數求值的標準規則對運算元進行求值，還會對標量類型進行隱式擴展。
運算元的求值順序是未定義的。
會按照內存中的順序將運算元賦值給最終矢量的相應元素。
即，將第一個運算元的第一個元素賦值給 result.x，
將第一個運算元的第二個元素（如果第一個運算元是標量，則此處為第二個運算元的第一個元素）
賦值給 result.y，等等。
如果只有單個標量運算元，則會將其複製並賦值給最終矢量的所有元素。
例如：
\startclc
float4	f = (float4)(1.0f, 2.0f, 3.0f, 4.0f);

uint4	u = (uint4)(1);		<- u will be (1, 1, 1, 1).

float4	f = (float4)((float2)(1.0f, 2.0f),
		     (float2)(3.0f, 4.0f));

float4	f = (float4)(1.0f, (float2)(2.0f, 3.0f), 4.0f);

float4	f = (float4)(1.0f, 2.0f);	<- error
\stopclc

% Vector Components
\subsection{矢量構件}

對於具有 1 到 4 個構件的矢量數據類型，其構件可以用 \ccmm{<vector_data_type>.xyzw} 來尋址。
矢量數據類型 \ctype{char2}、 \ctype{uchar2}、 \ctype{short2}、 \ctype{ushort2}、
 \ctype{int2}、 \ctype{uint2}、 \ctype{long2}、 \ctype{ulong2} 和 \ctype{float2}
 可以訪問元素 \ccmm{.xy}。
矢量數據類型 \ctype{char3}、 \ctype{uchar3}、 \ctype{short3}、 \ctype{ushort3}、
 \ctype{int3}、 \ctype{uint3}、 \ctype{long3}、 \ctype{ulong3} 和 \ctype{float3}
 可以訪問元素 \ccmm{.xyz}。
矢量數據類型 \ctype{char4}、 \ctype{uchar4}、 \ctype{short4}、 \ctype{ushort4}、
 \ctype{int4}、 \ctype{uint4}、 \ctype{long4}、 \ctype{ulong4} 和 \ctype{float4}
 可以訪問元素 \ccmm{.xyzw}。

如果所訪問的構件在矢量類型中並不具備，則視為錯誤，例如：
\startclc
float2 pos;	// is legal
pos.x = 1.0f;	// is illegal
pos.z = 1.0f;
float3 pos;	// is legal
pos.z = 1.0f;
pos.w = 1.0f;	// is illegal
\stopclc

在構件選擇文法中，可以將多個構件的名字附到句點（.）後面從而選擇多個構件。
\startclc
float4 c;

c.xyzw = (float4)(1.0f, 2.0f, 3.0f, 4.0f);
c.z = 1.0f;
c.xy = (float2)(3.0f, 4.0f);
c.xyz = (float3)(3.0f, 4.0f, 5.0f);
\stopclc

在構件選擇文法中，也可以將構件的順序打亂或重複。
\startclc
float4 pos = (float4)(1.0f, 2.0f, 3.0f, 4.0f);
float4 swiz= pos.wzyx; // swiz = (4.0f, 3.0f, 2.0f, 1.0f)
float4 dup = pos.xxyy; // dup = (1.0f, 1.0f, 2.0f, 2.0f)
\stopclc

構件組符號可以出現在表達式的左手邊。
要形當左值用，必須對矢量構件進行重排（swizzling），並且不能重複，
最終形成的左值是標量還是矢量取決於構件的數目。
每個構件都必須是 OpenCL 所支持的標量或矢量類型。
\startclc
float4 pos = (float4)(1.0f, 2.0f, 3.0f, 4.0f);
pos.xw = (float2)(5.0f, 6.0f);// pos = (5.0f, 2.0f, 3.0f, 6.0f)
pos.wx = (float2)(7.0f, 8.0f);// pos = (8.0f, 2.0f, 3.0f, 7.0f)
pos.xyz = (float3)(3.0f, 5.0f, 9.0f); // pos = (3.0f, 5.0f, 9.0f, 4.0f)
pos.xx = (float2)(3.0f, 4.0f);// illegal - 'x' used twice

// illegal - mismatch between float2 and float4
pos.xy = (float4)(1.0f, 2.0f, 3.0f, 4.0f);

float4 a, b, c, d;
float16 x;
x = (float16)(a, b, c, d);
x = (float16)(a.xxxx, b.xyz, c.xyz, d.xyz, a.yzw);

// illegal – component a.xxxxxxx is not a valid vector type
x = (float16)(a.xxxxxxx, b.xyz, c.xyz, d.xyz);
\stopclc

也可以用數值索引來訪問矢量數據類型的元素。
下表給出了可以使用的數值索引：

\placetable[here,force][tab:ni4bivdt]
{內建矢量數據類型的數值索引}
{\input{chapter_lgg/tbl/tbl_ni4bivdt.tex}}

數值索引前面必須加上字符 \ccmm{s} 或 \ccmm{S}。

下面例子中
\startclc
float8	f;
\stopclc
\ccmm{f.s0} 指代 \ctype{float8} 變量 \cvar{f} 的第一個元素，
而 \ccmm{f.s7} 則指代 \ctype{float8} 變量 \cvar{f} 的第八個元素。

下面例子中
\startclc
float16	x;
\stopclc
\ccmm{x.sa} （或 \ccmm{x.sA}）指代 \ctype{float16} 變量 \cvar{f} 的第十一個元素，
而 \ccmm{x.sf} （或 \ccmm{x.sF}）指代 \ctype{float16} 變量 \cvar{f} 的第十六個元素。

數值索引不能與 \ccmm{.xyzw} 混合使用。例如：
\startclc
float4 f, a;
a = f.x12w;	// illegal use of numeric indices with .xyzw
a.xyzw = f.s0123;	// valid
\stopclc

矢量數據類型可以使用後綴 \ccmm{.lo} （或 \ccmm{.even}）和 \ccmm{.hi} （或 \ccmm{.odd}）
得到小號的矢量類型或者將小號的數據類型組合成大號的矢量類型。
可以使用多級後綴 \ccmm{.lo} （或 \ccmm{.even}）和 \ccmm{.hi} （或 \ccmm{.odd}）
直到變成標量。

後綴 \ccmm{.lo} 指代的是矢量中索引值較小的那一半。
而後綴 \ccmm{.hi} 指代的是矢量中索引值較大的那一半。

後綴 \ccmm{.even} 指代的是矢量中索引值為偶數的元素。
而後綴 \ccmm{.odd} 指代的是矢量中索引值為奇數的元素。

下面的例子有助於我們理解它：
\startclc
float4 vf;

float2 low = vf.lo;	// returns vf.xy
float2 high = vf.hi;	// returns vf.zw

float2 even = vf.even;	// returns vf.xz
float2 odd = vf.odd;	// returns vf.yw
\stopclc

對於 3 構件的矢量類型應用後綴 \ccmm{.lo} （或 \ccmm{.even}）
和 \ccmm{.hi} （或 \ccmm{.odd}）時，
會將 3 構件矢量類型當成 4 構件矢量類型使用，且構件 \ccmm{w} 未定義。
下面給出了一些例子：
\startclc
float8	vf;
float4	odd = vf.odd;
float4	even = vf.even;
float2	high = vf.even.hi;
float2	low = vf.odd.lo;

// interleave L+R stereo stream
float4	left, right;
float8	interleaved;
interleaved.even = left;
interleaved.odd = right;

// deinterleave
left = interleaved.even;
right = interleaved.odd;

// transpose a 4x4 matrix
void transpose( float4 m[4] )
{
	// read matrix into a float16 vector
	float16 x = (float16)( m[0], m[1], m[2], m[3] );
	float16 t;

	//transpose
	t.even = x.lo;
	t.odd = x.hi;
	x.even = t.lo;
	x.odd = t.hi;
	//write back
	m[0] = x.lo.lo;	// { m[0][0], m[1][0], m[2][0], m[3][0] }
	m[1] = x.lo.hi;	// { m[0][1], m[1][1], m[2][1], m[3][1] }
	m[2] = x.hi.lo;	// { m[0][2], m[1][2], m[2][2], m[3][2] }
	m[3] = x.hi.hi;	// { m[0][3], m[1][3], m[2][3], m[3][3] }
}

float3	vf = (float3)(1.0f, 2.0f, 3.0f);
float2	low = vf.lo; // (1.0f, 2.0f);
float2	high = vf.hi; // (3.0f, undefined);
\stopclc

不能對矢量元素取址，否則會導致編譯錯誤。例如：
\startclc
float8	vf;

float	*f = &vf.x;		// is illegal
float2	*f2 = &vf.s07;		// is illegal

float4	*odd = &vf.odd;		// is illegal
float4	*even = &vf.even;	// is illegal
float2	*high = &vf.even.hi;	// is illegal
float2	*low = &vf.odd.lo;	// is illegal
\stopclc

% Aliasing Rules
\subsection{別名規則}

OpenCL C \cnglo{program} 符合 C99 中基於類型的別名規則
（在 C99 規範的節 6.5 的第 7 項中定義）。
為了應用這些別名規則， OpenCL C 內建矢量數據類型會被當成聚合（aggregate）類型
\footnote{也就是說，出於使用基於類型的別名規則的目的，
認為內建矢量數據類型等同於對應的數組類型。}。

% Keywords
\subsection{關鍵字}

下列名字將作為 OpenCL C 中的關鍵字而保留，不能挪作他用。
\startigBase
\item C99 中作為關鍵字所保留的名字。

\item \reftab{builtInVectorDataTypes}、\reftab{otherBuiltInDataTypes}
和\reftab{reservedDataTypes}中定義的 OpenCL C 數據類型。

\item 地址空間限定符：
 \cqlf{__global}、 \cqlf{global}、 \cqlf{__local}、 \cqlf{local}、
 \cqlf{__constant}、 \cqlf{constant}、 \cqlf{__private} 和 \cqlf{private}。

\item 函數限定符： \cqlf{__kernel} 和 \cqlf{kernel}。

\item 訪問限定符：
 \cqlf{__read_only}、 \cqlf{read_only}、 \cqlf{__write_only}、 \cqlf{write_only}、
 \cqlf{__read_write} 和 \cqlf{read_write}。
\stopigBase

