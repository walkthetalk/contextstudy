%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%head%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bTABLEhead
\bTR[background=color,backgroundcolor=gray]
  \bTH \ctype{cl_buffer_create_type} \eTH
  \bTH 描述 \eTH
  \eTR
\eTABLEhead

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  body  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bTABLEbody

\clenumdesc{CL_BUFFER_CREATE_TYPE_REGION}{
  创建一个用来描述\carg{buffer}中特定区块的\cnglo{bufobj}。

  \carg{buffer_create_info}指向如下数据结构：
\todo{clcintable}
%\startclc
%typedef struct _cl_buffer_region {
%	size_t origin;
%	size_t size;
%} cl_buffer_region;
%\stopclc
$(origin, size)$就是在\carg{buffer}中的偏移量和大小。

如果\carg{buffer}是用\cenum{CL_MEM_USE_HOST_PTR}创建的，所返回\cnglo{bufobj}的
\carg{host_ptr}就是$host\_ptr+origin$。

所返回的\cnglo{bufobj}引用了为\carg{buffer}分配的数据存储空间，并指向其中的特定区域
$(origin,size)$。

如果在\carg{buffer}中，区域$(origin,size)$越界了，则会在\carg{errcode_ret}中返回
\cenum{CL_INVALID_VALUE}。

如果\carg{size}是0，则返回\cenum{CL_INVALID_BUFFER_SIZE}。

如果与\carg{buffer}像关联的\cnglo{context}中没有一个设备的\cenum{CL_DEVICE_MEM_BASE_ADDR_ALIGN}与$origin$对齐，则会在\carg{errcode_ret}中返回
\cenum{CL_MISALIGNED_SUB_BUFFER_OFFSET}。

}

\eTABLEbody

