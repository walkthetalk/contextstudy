%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%head%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bTABLEhead
\bTR[background=color,backgroundcolor=gray]
  \bTH \ctype{cl_device_info} \eTH
  \bTH 返回类型 \eTH
  \bTH 描述 \eTH
  \eTR
\eTABLEhead

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  body  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bTABLEbody

\clenumretdesc{CL_DEVICE_TYPE}{cl_device_type}{
  \scopencl\cnglo{device}类型。当前所支持的值有：
  \startigBase
  \item \cenum{CL_DEVICE_TYPE_CPU}，
  \item \cenum{CL_DEVICE_TYPE_GPU}，
  \item \cenum{CL_DEVICE_TYPE_ACCELERATOR}，
  \item \cenum{CL_DEVICE_TYPE_DEFAULT}，或者
  \item 以上值的组合。
  \stopigBase
}

\clenumretdesc{CL_DEVICE_VENDOR_ID}{cl_uint}{
  唯一设备供应商标识符。例如可以是PCIe ID。
}

\clenumretdesc{CL_DEVICE_MAX_COMPUTE_UNITS}{cl_uint}{
  \scopencl\cnglo{device}上的并行计算核心的数目。最小值是1。
}

\clenumretdesc{CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS}{cl_uint}{
  数据并行执行模型中所用的全局和局部\cnglo{workitem}ID的最大维数。（参见 \capi{clEnqueueNDRangeKernel}）。最小值是3。
}

\clenumretdesc{CL_DEVICE_MAX_WORK_ITEM_SIZES}{size_t[]}{
给\capi{clEnqueueNDRangeKernel}所指定的\cnglo{workgrp}中每个维度上\cnglo{workitem}的最大数目。

返回\carg{n}个\ctype{size_t}表项。其中\carg{n}是查询\cenum{CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS}所返回的值。

最小值是(1, 1, 1)。
}

\clenumretdesc{CL_DEVICE_MAX_WORK_GROUP_SIZE}{size_t}{
一个使用数据并行执行模型执行\cnglo{kernel}的\cnglo{workgrp}中所能存放的\cnglo{workitem}的最大数目。（参见\capi{clEnqueueNDRangeKernel}）。最小值是1。
}

\clenumretdesc{
CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR 
CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT
CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT
CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG
CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT
CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE
CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF
}{cl_uint}{
可以放入矢量中的内建标量类型所期望的原生矢量的宽度。矢量宽度定义为可以存储到矢量中的标量元素的数目。

如果不支持扩展\cextname{cl_khr_fp64}，则\cenum{CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE}必须返回0。

如果不支持扩展\cextname{cl_khr_fp16}，则\cenum{CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF}必须返回0。
}

\clenumretdesc{
CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR
CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT
CL_DEVICE_NATIVE_VECTOR_WIDTH_INT
CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG
CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT
CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE
CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF
}{cl_uint}{
返回原生ISA矢量宽度。此矢量宽度定义为可以存储到矢量中的标量元素的数目。

如果不支持扩展\cextname{cl_khr_fp64}，则\cenum{CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE}必须返回0。

如果不支持扩展\cextname{cl_khr_fp16}，则\cenum{CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF}必须返回0。
}

\clenumretdesc{
CL_DEVICE_MAX_CLOCK_FREQUENCY
}{cl_uint}{
\cnglo{device}的时钟频率可以配置成的最大值，单位：MHZ。
}

\clenumretdesc{
CL_DEVICE_ADDRESS_BITS
}{cl_uint}{
运算设备的地址空间的缺省大小，无符号整形，单位：bit。当前所支持的有32bit和64bit。
}

\clenumretdesc{
CL_DEVICE_MAX_MEM_ALLOC_SIZE
}{cl_ulong}{
所能分配的内存对象大小的最大值，单位：字节（byte）。此值最小为$max(CL\_DEVICE\_GLOBAL\_MEM\_SIZE * 1/4, 128 * 1024 * 1024)$
}

\clenumretdesc{}{}{}

\clenumretdesc{
CL_DEVICE_IMAGE_SUPPORT
}{cl_bool}{
如果\scopencl\cnglo{device}支持图像，则为\cenum{CL_TRUE}，否则为\cenum{CL_FALSE}。
}

\clenumretdesc{
CL_DEVICE_MAX_READ_IMAGE_ARGS
}{cl_uint}{
\cnglo{kernel}可以读取的同步\cnglo{imgobj}的最大数目。如果\cenum{CL_DEVICE_IMAGE_SUPPORT}是\cenum{CL_TRUE}，则此值至少要是128。
}

\clenumretdesc{
CL_DEVICE_MAX_WRITE_IMAGE_ARGS
}{cl_uint}{
\cnglo{kernel}可以写入的同步\cnglo{imgobj}的最大数目。如果\cenum{CL_DEVICE_IMAGE_SUPPORT}是\cenum{CL_TRUE}，则此值至少要是128。
}

\clenumretdesc{
CL_DEVICE_IMAGE2D_MAX_WIDTH
}{size_t}{
2D图像的最大宽度，单位：像素。如果\cenum{CL_DEVICE_IMAGE_SUPPORT}是\cenum{CL_TRUE}，则此值至少要是8192。
}

\clenumretdesc{
CL_DEVICE_IMAGE2D_MAX_HEIGHT
}{size_t}{
2D图像的最大高度，单位：像素。如果\cenum{CL_DEVICE_IMAGE_SUPPORT}是\cenum{CL_TRUE}，则此值至少要是8192。
}

\clenumretdesc{
CL_DEVICE_IMAGE3D_MAX_WIDTH
}{size_t}{
3D图像的最大宽度，单位：像素。如果\cenum{CL_DEVICE_IMAGE_SUPPORT}是\cenum{CL_TRUE}，则此值至少要是2048。
}

\clenumretdesc{
CL_DEVICE_IMAGE3D_MAX_HEIGHT
}{size_t}{
3D图像的最大高度，单位：像素。如果\cenum{CL_DEVICE_IMAGE_SUPPORT}是\cenum{CL_TRUE}，则此值至少要是2048。
}

\clenumretdesc{
CL_DEVICE_IMAGE3D_MAX_DEPTH
}{size_t}{
3D图像的最大深度，单位：像素。如果\cenum{CL_DEVICE_IMAGE_SUPPORT}是\cenum{CL_TRUE}，则此值至少要是2048。
}

\clenumretdesc{
CL_DEVICE_MAX_SAMPLERS
}{cl_uint}{
一个\cnglo{kernel}中可以使用的\cnglo{sampler}的最大数目。关于\cnglo{sampler}的细节描述请参考\todo{section 6.11.13}。

如果\cenum{CL_DEVICE_IMAGE_SUPPORT}是\cenum{CL_TRUE}，则此值至少要是16。
}

\clenumretdesc{}{}{}

\clenumretdesc{
CL_DEVICE_MAX_PARAMETER_SIZE
}{size_t}{
可传递给\cnglo{kernel}的参数的最大字节数。

至少要是1024。如果是1024，则最多可传给\cnglo{kernel}128个参数。
}

\clenumretdesc{
CL_DEVICE_MEM_BASE_ADDR_ALIGN
}{cl_uint}{
其最小值是\cnglo{device}所支持的\scopencl内建数据类型中最大的那种数据类型的大小，单位：bit。（\scprofile FULL 中是\ctype{long16}，\scprofile EMBEDDED 中是\ctype{long16}或\ctype{int16}）
}

\clenumretdesc{
CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE
}{cl_uint}{
其最小值是\cnglo{device}所支持的\scopencl内建数据类型中最大的那种数据类型的大小，单位：byte。（\scprofile FULL 中是\ctype{long16}，\scprofile EMBEDDED 中是\ctype{long16}或\ctype{int16}）
}

\clenumretdesc{}{}{}

\clenumretdesc{
CL_DEVICE_SINGLE_FP_CONFIG
}{cl_device_fp_config}{
描述\cnglo{device}的单精度浮点\sccapability。用位域描述，支持下列值：
\startigBase
\item \cenum{CL_FP_DENORM}——支持\scdenorm。
\item \cenum{CL_FP_INF_NAN}——支持\scinf和\scqnan。
\item \cenum{CL_FP_ROUND_TO_NEAREST}——支持舍入到最近偶数（round to nearest even）。
\item \cenum{CL_FP_ROUND_TO_ZERO}——支持向零舍入（round to zero）。
\item \cenum{CL_FP_ROUND_TO_INF}——支持向正无穷和负无穷舍入。
\item \cenum{CL_FP_FMA}——支持\scieeeqwsellb\scnfma（fused multiply-add, FMA）。
\item \cenum{CL_FP_SOFT_FLOAT}——硬件中实现了基本的浮点运算（加、减、乘）。
\stopigBase

强制性的最小浮点\sccapability为：\cenum{CL_FP_ROUND_TO_NEAREST} \textbar \cenum{CL_FP_INF_NAN}。
}

\clenumretdesc{}{}{}

\clenumretdesc{
CL_DEVICE_GLOBAL_MEM_CACHE_TYPE
}{cl_device_mem_cache_type}{
所支持全局内存\sccache的类型。有效值有：
\startigBase
\item \cenum{CL_NONE},
\item \cenum{CL_READ_ONLY_CACHE}和
\item \cenum{CL_READ_WRITE_CACHE}。
\stopigBase
}

\clenumretdesc{
CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE
}{cl_uint}{
全局内存\sccacheline的大小，单位：byte。
}

\clenumretdesc{
CL_DEVICE_GLOBAL_MEM_CACHE_SIZE
}{cl_ulong}{
全局内存\sccache的大小，单位：byte。
}

\clenumretdesc{
CL_DEVICE_GLOBAL_MEM_SIZE
}{cl_ulong}{
全局\cnglo{device}内存\sccache的大小，单位：byte。
}

\clenumretdesc{
CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE
}{cl_ulong}{
一次所能分配的常量缓存最大字节数。最小值是64KB。
}

\clenumretdesc{
CL_DEVICE_MAX_CONSTANT_ARGS
}{cl_uint}{
一个\cnglo{kernel}最多能有多少参数带有限定符\cqlf{__constant}。最小值是8。
}

\clenumretdesc{}{}{}

\clenumretdesc{
CL_DEVICE_LOCAL_MEM_TYPE
}{cl_device_local_mem_type}{
所支持的局部内存的类型。可以是\cenum{CL_LOCAL}（意指专用的局部内存，如SRAM）或\cenum{CL_GLOBAL}。
}

\clenumretdesc{
CL_DEVICE_LOCAL_MEM_SIZE
}{cl_ulong}{
局部内存区的大小。最小值为32KB。
}

\clenumretdesc{
CL_DEVICE_ERROR_CORRECTION_SUPPORT
}{cl_bool}{
如果\cnglo{device}可以对运算设备的内存（包括全局内存和常量内存）进行纠错，则为\cenum{CL_TRUE}。否则为\cenum{CL_FALSE}。
}

\clenumretdesc{}{}{}

\clenumretdesc{
CL_DEVICE_HOST_UNIFIED_MEMORY
}{cl_bool}{
如果\cnglo{device}和\cnglo{host}共有一个统一的内存子系统，则为\cenum{CL_TRUE}，否则为\cenum{CL_FALSE}。
}

\clenumretdesc{}{}{}

\clenumretdesc{
CL_DEVICE_PROFILING_TIMER_RESOLUTION
}{size_t}{
描述\cnglo{device}定时器的分辨率。单位是纳秒。其细节参见\todo{section 5.9}。
}

\clenumretdesc{}{}{}

\clenumretdesc{
CL_DEVICE_ENDIAN_LITTLE
}{cl_bool}{
如果\scopencl\cnglo{device}是little-endian的，则为\cenum{CL_TRUE}，否则为\cenum{CL_FALSE}。
}

\clenumretdesc{
CL_DEVICE_AVAILABLE
}{cl_bool}{
如果\cnglo{device}可用，则为\cenum{CL_TRUE}，否则为\cenum{CL_FALSE}。
}

\clenumretdesc{}{}{}

\clenumretdesc{
CL_DEVICE_COMPILER_AVAILABLE
}{cl_bool}{
如果没有可用编译器来编译程序源码，则为\cenum{CL_FALSE}，否则是\cenum{CL_TRUE}。只有嵌入式平台\scprofile才能是\cenum{CL_FALSE}。
}

\clenumretdesc{}{}{}

\clenumretdesc{
CL_DEVICE_EXECUTION_CAPABILITIES
}{cl_device_exec_capabilities}{
描述\cnglo{device}的执行\sccapability。这是一个位域，有以下值：
\startigBase
\item \cenum{CL_EXEC_KERNEL}——此\scopencl\cnglo{device}可以执行\scopencl\cnglo{kernel}。
\item \cenum{CL_EXEC_NATIVE_KERNEL}——此\scopencl\cnglo{device}可以执行原生\cnglo{kernel}。
\stopigBase

其\sccapability至少要为：\cenum{CL_EXEC_KERNEL}。
}

\clenumretdesc{}{}{}

\clenumretdesc{
CL_DEVICE_QUEUE_PROPERTIES
}{cl_command_queue_properties}{
描述\cnglo{device}所支持的\cnglo{cmdq}属性。这是一个位域，包含以下值：
\startigBase
\item \cenum{CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE}
\item \cenum{CL_QUEUE_PROFILING_ENABLE}
\stopigBase

这些属性在\todo{table 5.1}中有所描述。

其\sccapability至少要为：\cenum{CL_QUEUE_PROFILING_ENABLE}。
}

\clenumretdesc{}{}{}

\clenumretdesc{
CL_DEVICE_PLATFORM
}{cl_platform_id}{
此\cnglo{device}所关联的\cnglo{platform}。
}

\clenumretdesc{}{}{}

\clenumretdesc{
CL_DEVICE_NAME
}{char[]}{
\cnglo{device}的名字。
}

\clenumretdesc{
CL_DEVICE_VENDOR
}{char[]}{
供应商的名字。
}

\clenumretdesc{
CL_DEVICE_VERSION
}{char[]}{
\scopencl软件驱动的版本，格式为：{\ftfmt major\_number.minor\_number}。
}

\clenumretdesc{
CL_DEVICE_PROFILE
}{char[]}{
\scopencl\scprofile字符串。返回\cnglo{device}所支持的\scprofile名称。可以是如下字符串中的一个\footnote{\getbuffer[footnoteprofile]}：p
\startigBase
\item \cenum{FULL_PROFILE}——如果设备支持\scopencl规范（核心规范所定义的功能，不需要支持任何扩展）。
\item \cenum{EMBEDDED_PROFILE}——如果设备支持\scopencl\scembpf。
\stopigBase
}

\clenumretdesc{
CL_DEVICE_VERSION
}{char[]}{
\scopencl版本字符串。返回\cnglo{device}所支持的\scopencl版本。格式如下：

{\ftfmt OpenCL<space><major\_version.minor\_version><space><vendor-specific information>}

所返回的{\ftfmt major\_version.minor\_version}的值将是\scver。
}

\clenumretdesc{
CL_DEVICE_OPENCL_C_VERSION
}{char[]}{
\scopenclc版本字符串。返回此\cnglo{device}的编译器所支持\scopenclc的最高版本。格式如下：

{\ftfmt OpenCL<space>C<space><major\_version.minor\_version><space><vendor-specific information>}

如果\cenum{CL_DEVICE_VERSION}是\scclver, {\ftfmt major\_version.minor\_version}必须是\scver。

如果\cenum{CL_DEVICE_VERSION}是\scopencl 1.0, {\ftfmt major\_version.minor\_version}可以是1.0或\scver。如果返回的是\scver，意味着此\scopencl 1.0\cnglo{device}支持\scclver规范中\todo{第六章}。
}

\clenumretdesc{
CL_DEVICE_EXTENSIONS
}{char[]}{
返回\cnglo{device}所支持的扩展名清单，以空格来分隔（扩展名称本身不包含空格）。
所返回清单当前可能包括供应商支持的扩展名，以及下列
已获Khronos批准的扩展名称中的一个或多个：

\cextname{cl_khr_fp64}

\cextname{cl_khr_int64_base_atomics}

\cextname{cl_khr_int64_extended_atomics}

\cextname{cl_khr_fp16}

\cextname{cl_khr_gl_sharing}

\cextname{cl_khr_gl_event}

\cextname{cl_khr_d3d10_sharing}

对于支持\scopenclc \scver的\cnglo{device}，所返回的清单中必须包含下列已经由Khronos批准的扩展名：

\cextname{cl_khr_global_int32_base_atomics}

\cextname{cl_khr_global_int32_extended_atomics}

\cextname{cl_khr_local_int32_base_atomics}

\cextname{cl_khr_local_int32_extended_atomics}

\cextname{cl_khr_byte_addressable_store}

对于这些扩展的详细描述请参见\todo{第九章}。
}


\eTABLEbody

